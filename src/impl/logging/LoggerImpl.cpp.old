#include <list>
#include <iomanip>

#include "cpputils/logger_impl.h"

using namespace logging;

std::string EmptyString;

consumer::consumer(const std::string& n, bool autoRegister) :
    _name(n)
{
    if (autoRegister)
        register_consumer(*this);
}

consumer::~consumer()
    { unregister_consumer(*this); }

void consumer_stream::log(data_ptr_s data)
{
    std::lock_guard<std::mutex> lk(_mutex);

    using namespace std;
    if (!data)
        return;
    auto& d = *data;
    auto t = std::chrono::duration_cast<std::chrono::duration<double, std::ratio<1>>>(d.time.time_since_epoch()).count();
    auto f = d.file;
    if (f)
    {
        auto tmp = strrchr(f, '/');
        if (tmp)
            f = tmp + 1;
    }
    else
        f = "unknown";

    StreamFormatSaver formatSaver(*_stream);
    if (t >= 0)                         *_stream << "["   << fixed << setfill(' ') << setw(17) <<  setprecision(6) << t << "] ";
    switch(d.level)
    {
        case level::Debug:              *_stream << "DEBUG "; break;
        case level::Info:               *_stream << "INFO  "; break;
        case level::Warn:               *_stream << "WARN  "; break;
        case level::Error:              *_stream << "ERROR "; break;
    }

    if (d.sender)                       *_stream << "0x"  << hex << setw(2 * sizeof(void*)) << setfill('0') << d.sender;
    else                                *_stream << "                  ";
    if (d.thread != std::thread::id())  *_stream << "@"   << hex << setw(2 * sizeof(void*)) << setfill('0') << d.thread;
    else                                *_stream << "                 ";
    if (!d.name.empty())                *_stream << " '" << d.name << "'";
    if (d.line)                         *_stream << " - " << setw(25) << setfill(' ') << f << ":" << setw(5) << setfill(' ') << dec << d.line;
    if (!d.message.empty())
    {
        *_stream << ": "  << d.message;
        if (d.message.back() != '\n')
            *_stream << std::endl;
    }
    else
        *_stream << std::endl;
}



bool matcher_all::match(const logger& logger) const
    { return true; }

bool matcher_all::match(const consumer& consumer) const
    { return true; }

bool matcher_regex::match(const logger& logger) const
    { return !logger.name().empty() && std::regex_match(logger.name(), _regex) != _invert; }

bool matcher_regex::match(const consumer& consumer) const
    { return !consumer.name().empty() && std::regex_match(consumer.name(), _regex) != _invert; }

bool matcher_default::match(const logger& logger) const
    { return &_defaultLogger == &logger; }




const std::string& logger::name() const
    { return EmptyString; }

bool logger::is_enabled(level level) const
    { return false; }

void logger::log(data_ptr_s data) const
    { /* no op */ }



const std::string& logger_impl::name() const
    { return _name; }

bool logger_impl::is_enabled(level level) const
{
    for (auto& rule : _rules)
    {
        if (rule->is_enabled(level))
            return true;
    }
    return false;
}

void logger_impl::log(data_ptr_s data) const
{
    std::lock_guard<std::mutex> lk(_mutex);
    for (auto& r : _rules)
        r->log(data);
}

namespace logging
{
    
}